先调速度环，再加上角度环，速度环内环，角度环内环，速度环调pi，角度环先调pd再加i，角度环kp不能太大，不能让它在中值处震荡（抖），在不让它在中值处抖的最大kp后（找这个值时同时也要增大kd）增大速度环的kp或ki(两个环联调)，实在
不能调很快平衡时（在左右走能比较平稳的一直走），增大角度环的ki,适当后即可在中值附近平衡
位置环+（角度环->速度环）
位置环：确保在原地 一般是p或pi
不能 位置环->（角度环+速度环）
举例：车向后倾，角度环与速度环给想后的转速，而位置环会给向前的速度，所以不能位置环的输出作为角度环的输入
往前走或往后走：写一个位置式pid（应该是）PWM = PID_Calc(&site1,MotorSpeed2-MotorSpeed1,10);(10是希望两个编码器通过转弯来取得差值10这里是右转来做到转弯)输出给速度环期望值作偏差（加减）
PWM1 = PID_Calc(&speed1, MotorSpeed1-100,-angle1.out-(uint8_t)PWM);//右轮 = 1
PWM2 = PID_Calc(&speed2, MotorSpeed2-100,-angle2.out+(uint8_t)PWM);	//左轮 = 2
再给电机pwm
串级pid切不可和其他pid并（也许）但可以把要并的pid输出放在最后一环（如速度环）的期望值那里作加减运算
把位置环的期望改为0，再把输出量给速度环期望作偏差，可以使小车尽量直走
补充：速度环空载（把车驾起来）和负载（车在地上）调的pid是不太一样的，学长建议把空载的pid超调一点点再放地上跑，我觉得也可以后期联调再改变速度环pid的值